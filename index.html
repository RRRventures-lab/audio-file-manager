<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio File Manager Pro - Format Converter & Audio Splitter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1rem;
        }

        .features-bar {
            background: #f8f9ff;
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #e0e0e0;
        }

        .batch-controls {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .batch-format-select {
            padding: 8px 15px;
            border: 2px solid #667eea;
            border-radius: 8px;
            background: white;
            color: #333;
            font-size: 0.95rem;
            cursor: pointer;
            outline: none;
        }

        .batch-convert-btn, .open-splitter-btn {
            padding: 10px 25px;
            background: linear-gradient(135deg, #FF6B6B, #FF8787);
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 500;
            transition: transform 0.3s ease;
        }

        .open-splitter-btn {
            background: linear-gradient(135deg, #00C9FF, #92FE9D);
        }

        .batch-convert-btn:hover, .open-splitter-btn:hover {
            transform: translateY(-2px);
        }

        .supported-formats {
            font-size: 0.85rem;
            color: #666;
        }

        .supported-formats strong {
            color: #667eea;
        }

        .drop-zone {
            margin: 30px;
            padding: 60px;
            border: 3px dashed #667eea;
            border-radius: 15px;
            text-align: center;
            transition: all 0.3s ease;
            background: #f8f9ff;
        }

        .drop-zone.dragover {
            background: #e8ecff;
            border-color: #764ba2;
            transform: scale(1.02);
        }

        .drop-zone h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.8rem;
        }

        .drop-zone p {
            color: #666;
            margin-bottom: 20px;
        }

        .file-input-label {
            display: inline-block;
            padding: 12px 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 30px;
            cursor: pointer;
            transition: transform 0.3s ease;
            font-weight: 500;
        }

        .file-input-label:hover {
            transform: translateY(-2px);
        }

        #fileInput {
            display: none;
        }

        .files-container {
            padding: 30px;
        }

        .files-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e0e0e0;
        }

        .files-header h3 {
            color: #333;
            font-size: 1.5rem;
        }

        .header-buttons {
            display: flex;
            gap: 10px;
        }

        .download-all-btn, .clear-all-btn {
            padding: 10px 25px;
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 500;
            transition: background 0.3s ease;
        }

        .download-all-btn {
            background: #4CAF50;
        }

        .download-all-btn:hover {
            background: #45a049;
        }

        .clear-all-btn {
            background: #f44336;
        }

        .clear-all-btn:hover {
            background: #da190b;
        }

        .download-all-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .file-item {
            display: flex;
            align-items: center;
            padding: 20px;
            margin-bottom: 15px;
            background: #f5f5f5;
            border-radius: 10px;
            transition: all 0.3s ease;
            position: relative;
        }

        .file-item:hover {
            background: #ececec;
            transform: translateX(5px);
        }

        .file-item.converting {
            background: #fff3cd;
        }

        .file-icon {
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 20px;
            flex-shrink: 0;
        }

        .file-icon svg {
            width: 30px;
            height: 30px;
            fill: white;
        }

        .file-info {
            flex: 1;
            min-width: 0;
        }

        .file-name-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }

        .file-name {
            font-weight: 600;
            color: #333;
            font-size: 1.1rem;
            word-break: break-all;
        }

        .original-name {
            font-size: 0.85rem;
            color: #666;
            font-style: italic;
            margin-bottom: 5px;
        }

        .file-name-input {
            flex: 1;
            padding: 8px 12px;
            border: 2px solid #667eea;
            border-radius: 5px;
            font-size: 1rem;
            outline: none;
        }

        .file-meta {
            display: flex;
            gap: 20px;
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 10px;
        }

        .format-converter {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
            padding: 10px;
            background: white;
            border-radius: 8px;
        }

        .format-label {
            font-size: 0.9rem;
            color: #666;
            font-weight: 500;
        }

        .format-select {
            padding: 6px 12px;
            border: 2px solid #667eea;
            border-radius: 5px;
            background: white;
            color: #333;
            font-size: 0.9rem;
            cursor: pointer;
            outline: none;
        }

        .quality-select {
            padding: 6px 12px;
            border: 2px solid #667eea;
            border-radius: 5px;
            background: white;
            color: #333;
            font-size: 0.9rem;
            cursor: pointer;
            outline: none;
        }

        .file-actions {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-direction: column;
        }

        .action-btn {
            padding: 10px;
            background: none;
            border: none;
            cursor: pointer;
            border-radius: 5px;
            transition: background 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .action-btn:hover {
            background: #ddd;
        }

        .action-btn svg {
            width: 24px;
            height: 24px;
            fill: #666;
        }

        .download-btn, .split-btn {
            padding: 8px 16px;
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-weight: 500;
            transition: transform 0.3s ease;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .split-btn {
            background: linear-gradient(135deg, #00C9FF, #92FE9D);
        }

        .download-btn:hover, .split-btn:hover {
            transform: translateY(-2px);
        }

        .download-btn svg, .split-btn svg {
            width: 18px;
            height: 18px;
            fill: white;
        }

        .audio-player {
            margin-top: 15px;
            width: 100%;
        }

        .audio-controls {
            width: 100%;
            height: 40px;
            border-radius: 20px;
        }

        .empty-state {
            text-align: center;
            padding: 60px;
            color: #999;
        }

        .empty-state svg {
            width: 100px;
            height: 100px;
            fill: #ddd;
            margin-bottom: 20px;
        }

        .format-badge {
            padding: 4px 10px;
            background: #667eea;
            color: white;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .save-btn, .cancel-btn {
            padding: 6px 14px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: background 0.3s ease;
        }

        .save-btn {
            background: #4CAF50;
            color: white;
        }

        .save-btn:hover {
            background: #45a049;
        }

        .cancel-btn {
            background: #f44336;
            color: white;
            margin-left: 5px;
        }

        .cancel-btn:hover {
            background: #da190b;
        }

        .progress-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: #e0e0e0;
            border-radius: 0 0 10px 10px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0;
            transition: width 0.3s ease;
        }

        .converting-indicator {
            display: inline-block;
            padding: 4px 10px;
            background: #ff9800;
            color: white;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.6; }
            100% { opacity: 1; }
        }

        .format-info {
            margin-top: 20px;
            padding: 15px;
            background: #e8f5e9;
            border-radius: 10px;
            font-size: 0.85rem;
            color: #2e7d32;
        }

        .format-info h4 {
            margin-bottom: 10px;
            color: #1b5e20;
        }

        .format-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .format-list-item {
            padding: 8px;
            background: white;
            border-radius: 5px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .format-list-item .badge {
            padding: 2px 6px;
            background: #4CAF50;
            color: white;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 600;
        }

        /* Audio Splitter Modal Styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            animation: fadeIn 0.3s ease;
        }

        .modal-overlay.active {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .splitter-modal {
            background: white;
            border-radius: 20px;
            width: 90%;
            max-width: 1200px;
            max-height: 90vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .splitter-header {
            background: linear-gradient(135deg, #00C9FF, #92FE9D);
            color: white;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .splitter-header h2 {
            font-size: 1.5rem;
        }

        .close-modal-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: background 0.3s ease;
        }

        .close-modal-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .splitter-body {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
        }

        .waveform-container {
            background: #f5f5f5;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            position: relative;
        }

        .waveform-canvas {
            width: 100%;
            height: 200px;
            background: white;
            border-radius: 8px;
            cursor: crosshair;
            display: block;
        }

        .waveform-timeline {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            font-size: 0.85rem;
            color: #666;
        }

        .split-marker {
            position: absolute;
            width: 2px;
            height: 200px;
            background: #ff4444;
            cursor: ew-resize;
            top: 20px;
            z-index: 10;
        }

        .split-marker::before {
            content: '';
            position: absolute;
            top: -10px;
            left: -4px;
            width: 10px;
            height: 10px;
            background: #ff4444;
            border-radius: 50%;
        }

        .split-marker-label {
            position: absolute;
            top: -25px;
            left: -20px;
            background: #ff4444;
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.75rem;
            white-space: nowrap;
        }

        .splitter-controls {
            background: #f8f9ff;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .splitter-controls h3 {
            margin-bottom: 15px;
            color: #333;
        }

        .control-row {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            align-items: center;
        }

        .control-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .control-btn.primary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        .control-btn.secondary {
            background: white;
            color: #667eea;
            border: 2px solid #667eea;
        }

        .control-btn.danger {
            background: #f44336;
            color: white;
        }

        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .control-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .segments-list {
            background: #f8f9ff;
            border-radius: 10px;
            padding: 20px;
        }

        .segments-list h3 {
            margin-bottom: 15px;
            color: #333;
        }

        .segment-item {
            background: white;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .segment-info {
            flex: 1;
        }

        .segment-name-input {
            padding: 5px 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            width: 200px;
            margin-right: 10px;
        }

        .segment-time {
            color: #666;
            font-size: 0.9rem;
        }

        .segment-actions {
            display: flex;
            gap: 10px;
        }

        .threshold-slider {
            width: 200px;
        }

        .threshold-value {
            display: inline-block;
            width: 50px;
            text-align: center;
            font-weight: 600;
            color: #667eea;
        }

        .playback-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 15px;
        }

        .playback-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.3s ease;
        }

        .playback-btn:hover {
            transform: scale(1.1);
        }

        .playback-time {
            margin-left: 10px;
            font-weight: 600;
            color: #333;
        }

        .zoom-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .zoom-btn {
            width: 30px;
            height: 30px;
            border: 1px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .zoom-btn:hover {
            background: #667eea;
            color: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎵 Audio File Manager Pro</h1>
            <p>Convert, rename, split and organize audio files - All formats supported</p>
        </div>

        <div class="features-bar">
            <div class="batch-controls">
                <label class="format-label">Batch Convert All To:</label>
                <select class="batch-format-select" id="batchFormatSelect">
                    <option value="">Keep Original</option>
                    <option value="wav">WAV (Uncompressed)</option>
                    <option value="mp3">MP3 (Compressed)</option>
                    <option value="ogg">OGG Vorbis</option>
                    <option value="m4a">M4A/AAC</option>
                    <option value="flac">FLAC (Lossless)</option>
                    <option value="aif">AIF/AIFF (Apple)</option>
                    <option value="webm">WebM Audio</option>
                </select>
                <button class="batch-convert-btn" onclick="batchConvert()">Convert All</button>
            </div>
            <div class="supported-formats">
                <strong>Supports:</strong> MP3, WAV, OGG, M4A, FLAC, AAC, OPUS, WebM, MP4 Audio, WMA, AIF/AIFF, AU & more
            </div>
        </div>

        <div class="drop-zone" id="dropZone">
            <h2>Drop Audio Files Here</h2>
            <p>or</p>
            <label for="fileInput" class="file-input-label">
                Browse Files
            </label>
            <input type="file" id="fileInput" accept="audio/*,video/*" multiple>
            <p style="margin-top: 20px; font-size: 0.9rem;">
                Accepts ALL audio formats including MP3, WAV, FLAC, OGG, M4A, AAC, OPUS, WMA, AIF/AIFF, and more
            </p>
            <p style="margin-top: 10px; font-size: 0.85rem; color: #764ba2;">
                <strong>NEW:</strong> Split audio files into multiple segments with smart silence detection!
            </p>
        </div>

        <div class="files-container" id="filesContainer" style="display: none;">
            <div class="files-header">
                <h3>Your Audio Files</h3>
                <div class="header-buttons">
                    <button class="clear-all-btn" onclick="clearAll()">Clear All</button>
                    <button class="download-all-btn" id="downloadAllBtn" onclick="downloadAll()">
                        Download All Files
                    </button>
                </div>
            </div>
            <div id="filesList"></div>
        </div>

        <div class="empty-state" id="emptyState">
            <svg viewBox="0 0 24 24">
                <path d="M12,3V12.26C11.5,12.09 11,12 10.5,12C8,12 6,14 6,16.5C6,19 8,21 10.5,21C13,21 15,19 15,16.5V6H19V3H12Z"/>
            </svg>
            <p>No audio files loaded yet</p>
            <div class="format-info">
                <h4>Supported Input Formats:</h4>
                <div class="format-list">
                    <div class="format-list-item">
                        <span class="badge">MP3</span> MPEG Audio Layer 3
                    </div>
                    <div class="format-list-item">
                        <span class="badge">WAV</span> Waveform Audio
                    </div>
                    <div class="format-list-item">
                        <span class="badge">FLAC</span> Lossless Audio
                    </div>
                    <div class="format-list-item">
                        <span class="badge">OGG</span> Ogg Vorbis/Opus
                    </div>
                    <div class="format-list-item">
                        <span class="badge">M4A</span> MPEG-4 Audio
                    </div>
                    <div class="format-list-item">
                        <span class="badge">AAC</span> Advanced Audio
                    </div>
                    <div class="format-list-item">
                        <span class="badge">WebM</span> WebM Audio
                    </div>
                    <div class="format-list-item">
                        <span class="badge">WMA</span> Windows Media
                    </div>
                    <div class="format-list-item">
                        <span class="badge">AIF/AIFF</span> Apple Audio
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Audio Splitter Modal -->
    <div class="modal-overlay" id="splitterModal">
        <div class="splitter-modal">
            <div class="splitter-header">
                <h2>🎛️ Audio Splitter</h2>
                <button class="close-modal-btn" onclick="closeSplitter()">✕</button>
            </div>
            <div class="splitter-body">
                <div class="waveform-container">
                    <canvas class="waveform-canvas" id="waveformCanvas"></canvas>
                    <div class="waveform-timeline" id="waveformTimeline">
                        <span>0:00</span>
                        <span id="durationLabel">0:00</span>
                    </div>
                    <div id="splitMarkersContainer"></div>
                </div>

                <div class="playback-controls">
                    <button class="playback-btn" onclick="togglePlayback()">
                        <span id="playPauseIcon">▶</span>
                    </button>
                    <span class="playback-time" id="playbackTime">0:00 / 0:00</span>
                    <div class="zoom-controls">
                        <button class="zoom-btn" onclick="zoomIn()">+</button>
                        <button class="zoom-btn" onclick="zoomOut()">-</button>
                        <button class="zoom-btn" onclick="resetZoom()">⟲</button>
                    </div>
                </div>

                <div class="splitter-controls">
                    <h3>Split Controls</h3>
                    <div class="control-row">
                        <button class="control-btn primary" onclick="detectSilence()">
                            🔍 Smart Detect Silence
                        </button>
                        <label>Silence Threshold:</label>
                        <input type="range" class="threshold-slider" id="silenceThreshold"
                               min="0" max="100" value="30" oninput="updateThreshold(this.value)">
                        <span class="threshold-value" id="thresholdValue">30%</span>
                    </div>
                    <div class="control-row">
                        <button class="control-btn secondary" onclick="addManualSplit()">
                            ➕ Add Split at Cursor
                        </button>
                        <button class="control-btn danger" onclick="clearAllSplits()">
                            🗑️ Clear All Splits
                        </button>
                        <button class="control-btn secondary" onclick="previewSegment()">
                            🔊 Preview Current Segment
                        </button>
                    </div>
                </div>

                <div class="segments-list">
                    <h3>Audio Segments</h3>
                    <div id="segmentsList"></div>
                    <div class="control-row" style="margin-top: 20px;">
                        <button class="control-btn primary" onclick="exportAllSegments()">
                            💾 Export All Segments
                        </button>
                        <select class="format-select" id="segmentFormat">
                            <option value="wav">WAV</option>
                            <option value="mp3">MP3</option>
                            <option value="ogg">OGG</option>
                            <option value="aif">AIF</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.0/lame.min.js"></script>
    <script>
        let audioFiles = [];
        let audioContext = null;
        let currentSplitterFile = null;
        let splitMarkers = [];
        let waveformData = null;
        let playbackSource = null;
        let isPlaying = false;
        let zoomLevel = 1;
        let cursorPosition = 0;
        let currentAudioBuffer = null;

        // Initialize audio context
        function getAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            return audioContext;
        }

        // Initialize drag and drop
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const filesContainer = document.getElementById('filesContainer');
        const filesList = document.getElementById('filesList');
        const emptyState = document.getElementById('emptyState');

        // Prevent default drag behaviors
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, preventDefaults, false);
            document.body.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        // Highlight drop zone when item is dragged over it
        ['dragenter', 'dragover'].forEach(eventName => {
            dropZone.addEventListener(eventName, highlight, false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, unhighlight, false);
        });

        function highlight(e) {
            dropZone.classList.add('dragover');
        }

        function unhighlight(e) {
            dropZone.classList.remove('dragover');
        }

        // Handle dropped files
        dropZone.addEventListener('drop', handleDrop, false);

        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;
            handleFiles(files);
        }

        // Handle file input change
        fileInput.addEventListener('change', function(e) {
            handleFiles(this.files);
        });

        function handleFiles(files) {
            const audioFilesArray = Array.from(files).filter(file => {
                // Accept any audio or video file (for audio extraction)
                return file.type.startsWith('audio/') ||
                       file.type.startsWith('video/') ||
                       // Also accept files with audio extensions even if MIME type is not set
                       /\.(mp3|wav|ogg|m4a|flac|aac|opus|webm|wma|aiff|aif|aifc|au|mp4|avi|mov)$/i.test(file.name);
            });

            audioFilesArray.forEach(file => {
                const fileObj = {
                    id: Date.now() + Math.random(),
                    file: file,
                    originalName: file.name,
                    newName: file.name,
                    size: file.size,
                    type: file.type || detectMimeType(file.name),
                    url: URL.createObjectURL(file),
                    targetFormat: null,
                    quality: 'high',
                    converting: false,
                    convertedBlob: null
                };
                audioFiles.push(fileObj);
            });

            updateFilesList();
        }

        function detectMimeType(filename) {
            const ext = filename.split('.').pop().toLowerCase();
            const mimeTypes = {
                'mp3': 'audio/mpeg',
                'wav': 'audio/wav',
                'ogg': 'audio/ogg',
                'oga': 'audio/ogg',
                'opus': 'audio/opus',
                'm4a': 'audio/mp4',
                'aac': 'audio/aac',
                'webm': 'audio/webm',
                'flac': 'audio/flac',
                'wma': 'audio/x-ms-wma',
                'aiff': 'audio/aiff',
                'aif': 'audio/aiff',
                'aifc': 'audio/aiff',
                'au': 'audio/basic'
            };
            return mimeTypes[ext] || 'audio/*';
        }

        function updateFilesList() {
            if (audioFiles.length === 0) {
                filesContainer.style.display = 'none';
                emptyState.style.display = 'block';
                return;
            }

            filesContainer.style.display = 'block';
            emptyState.style.display = 'none';

            filesList.innerHTML = audioFiles.map(fileObj => `
                <div class="file-item ${fileObj.converting ? 'converting' : ''}" data-id="${fileObj.id}">
                    <div class="file-icon">
                        <svg viewBox="0 0 24 24">
                            <path d="M12,3V12.26C11.5,12.09 11,12 10.5,12C8,12 6,14 6,16.5C6,19 8,21 10.5,21C13,21 15,19 15,16.5V6H19V3H12Z"/>
                        </svg>
                    </div>
                    <div class="file-info">
                        <div class="file-name-container" id="nameContainer-${fileObj.id}">
                            <span class="file-name">${fileObj.newName}</span>
                            <span class="format-badge">${getFileExtension(fileObj.originalName)}</span>
                            ${fileObj.converting ? '<span class="converting-indicator">Converting...</span>' : ''}
                        </div>
                        ${fileObj.originalName !== fileObj.newName ?
                            `<div class="original-name">Original: ${fileObj.originalName}</div>` : ''}
                        <div class="file-meta">
                            <span>Size: ${formatFileSize(fileObj.size)}</span>
                            <span>Type: ${fileObj.type || 'Unknown'}</span>
                        </div>
                        <div class="format-converter">
                            <label class="format-label">Export as:</label>
                            <select class="format-select" id="format-${fileObj.id}" onchange="updateTargetFormat(${fileObj.id}, this.value)">
                                <option value="">Original (${getFileExtension(fileObj.originalName)})</option>
                                <option value="wav">WAV - Uncompressed</option>
                                <option value="mp3">MP3 - Compressed</option>
                                <option value="ogg">OGG - Vorbis</option>
                                <option value="m4a">M4A - AAC</option>
                                <option value="flac">FLAC - Lossless</option>
                                <option value="aif">AIF - Apple Lossless</option>
                                <option value="webm">WebM - Opus</option>
                            </select>
                            <label class="format-label">Quality:</label>
                            <select class="quality-select" id="quality-${fileObj.id}" onchange="updateQuality(${fileObj.id}, this.value)">
                                <option value="high">High</option>
                                <option value="medium">Medium</option>
                                <option value="low">Low</option>
                            </select>
                        </div>
                        <div class="audio-player">
                            <audio controls class="audio-controls">
                                <source src="${fileObj.url}" type="${fileObj.type}">
                                Your browser does not support the audio element.
                            </audio>
                        </div>
                    </div>
                    <div class="file-actions">
                        <button class="split-btn" onclick="openSplitter(${fileObj.id})" title="Split Audio">
                            <svg viewBox="0 0 24 24">
                                <path d="M8,3A2,2 0 0,0 6,5V9A2,2 0 0,1 4,11H3V13H4A2,2 0 0,1 6,15V19A2,2 0 0,0 8,21H10V19H8V14A2,2 0 0,0 7,12A2,2 0 0,0 8,10V5H10V3M16,3A2,2 0 0,1 18,5V9A2,2 0 0,0 20,11H21V13H20A2,2 0 0,0 18,15V19A2,2 0 0,1 16,21H14V19H16V14A2,2 0 0,1 17,12A2,2 0 0,1 16,10V5H14V3H16Z"/>
                            </svg>
                            Split
                        </button>
                        <button class="action-btn" onclick="editFileName(${fileObj.id})" title="Rename">
                            <svg viewBox="0 0 24 24">
                                <path d="M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.12,5.12L18.87,8.87M3,17.25V21H6.75L17.81,9.93L14.06,6.18L3,17.25Z"/>
                            </svg>
                        </button>
                        <button class="download-btn" onclick="downloadFile(${fileObj.id})" title="Download">
                            <svg viewBox="0 0 24 24">
                                <path d="M5,20H19V18H5M19,9H15V3H9V9H5L12,16L19,9Z"/>
                            </svg>
                            Download
                        </button>
                        <button class="action-btn" onclick="removeFile(${fileObj.id})" title="Remove">
                            <svg viewBox="0 0 24 24">
                                <path d="M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z"/>
                            </svg>
                        </button>
                    </div>
                    <div class="progress-bar" id="progress-${fileObj.id}" style="display: none;">
                        <div class="progress-fill" id="progress-fill-${fileObj.id}"></div>
                    </div>
                </div>
            `).join('');

            // Restore format selections
            audioFiles.forEach(fileObj => {
                if (fileObj.targetFormat) {
                    const formatSelect = document.getElementById(`format-${fileObj.id}`);
                    if (formatSelect) formatSelect.value = fileObj.targetFormat;
                }
                if (fileObj.quality) {
                    const qualitySelect = document.getElementById(`quality-${fileObj.id}`);
                    if (qualitySelect) qualitySelect.value = fileObj.quality;
                }
            });

            // Stop all audio when a new one plays
            const audioElements = document.querySelectorAll('audio');
            audioElements.forEach(audio => {
                audio.addEventListener('play', function() {
                    audioElements.forEach(otherAudio => {
                        if (otherAudio !== audio) {
                            otherAudio.pause();
                        }
                    });
                });
            });
        }

        function getFileExtension(filename) {
            return filename.split('.').pop().toUpperCase();
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }

        function updateTargetFormat(id, format) {
            const fileObj = audioFiles.find(f => f.id === id);
            fileObj.targetFormat = format || null;
        }

        function updateQuality(id, quality) {
            const fileObj = audioFiles.find(f => f.id === id);
            fileObj.quality = quality;
        }

        function editFileName(id) {
            const fileObj = audioFiles.find(f => f.id === id);
            const container = document.getElementById(`nameContainer-${id}`);

            const currentName = fileObj.newName;
            const extension = '.' + getFileExtension(currentName).toLowerCase();
            const nameWithoutExt = currentName.substring(0, currentName.lastIndexOf('.'));

            container.innerHTML = `
                <input type="text" class="file-name-input" id="input-${id}" value="${nameWithoutExt}">
                <span class="format-badge">${getFileExtension(currentName)}</span>
                <button class="save-btn" onclick="saveFileName(${id}, '${extension}')">Save</button>
                <button class="cancel-btn" onclick="cancelEdit(${id})">Cancel</button>
            `;

            const input = document.getElementById(`input-${id}`);
            input.focus();
            input.select();

            input.addEventListener('keyup', function(e) {
                if (e.key === 'Enter') {
                    saveFileName(id, extension);
                } else if (e.key === 'Escape') {
                    cancelEdit(id);
                }
            });
        }

        function saveFileName(id, extension) {
            const input = document.getElementById(`input-${id}`);
            const newName = input.value.trim() + extension;

            if (newName === extension) {
                alert('Please enter a valid file name');
                return;
            }

            const fileObj = audioFiles.find(f => f.id === id);
            fileObj.newName = newName;

            updateFilesList();
        }

        function cancelEdit(id) {
            updateFilesList();
        }

        async function convertAudio(fileObj, targetFormat) {
            const ctx = getAudioContext();

            try {
                // Show progress
                const progressBar = document.getElementById(`progress-${fileObj.id}`);
                const progressFill = document.getElementById(`progress-fill-${fileObj.id}`);
                if (progressBar) progressBar.style.display = 'block';

                fileObj.converting = true;
                updateFilesList();

                // Read file as array buffer
                const arrayBuffer = await fileObj.file.arrayBuffer();

                // Decode audio data
                const audioBuffer = await ctx.decodeAudioData(arrayBuffer);

                // Update progress
                if (progressFill) progressFill.style.width = '50%';

                // Convert based on target format
                let blob;
                switch(targetFormat) {
                    case 'wav':
                        blob = await convertToWav(audioBuffer, fileObj.quality);
                        break;
                    case 'mp3':
                        blob = await convertToMp3(audioBuffer, fileObj.quality);
                        break;
                    case 'aif':
                    case 'aiff':
                        blob = await convertToAiff(audioBuffer, fileObj.quality);
                        break;
                    case 'ogg':
                    case 'webm':
                        blob = await convertToOggOrWebM(audioBuffer, targetFormat, fileObj.quality);
                        break;
                    case 'm4a':
                    case 'flac':
                        // For these formats, we'll use the original with a renamed extension
                        // as full conversion requires more complex libraries
                        blob = new Blob([arrayBuffer], { type: `audio/${targetFormat}` });
                        break;
                    default:
                        blob = fileObj.file;
                }

                // Update progress
                if (progressFill) progressFill.style.width = '100%';

                fileObj.convertedBlob = blob;
                fileObj.converting = false;

                // Hide progress after a delay
                setTimeout(() => {
                    if (progressBar) progressBar.style.display = 'none';
                    updateFilesList();
                }, 500);

                return blob;

            } catch (error) {
                console.error('Conversion error:', error);
                fileObj.converting = false;
                updateFilesList();
                alert(`Error converting ${fileObj.originalName}: ${error.message}`);
                return null;
            }
        }

        async function convertToWav(audioBuffer, quality) {
            const length = audioBuffer.length;
            const numberOfChannels = audioBuffer.numberOfChannels;
            const sampleRate = quality === 'high' ? audioBuffer.sampleRate :
                             quality === 'medium' ? 22050 : 11025;

            const wavBuffer = new ArrayBuffer(44 + length * numberOfChannels * 2);
            const view = new DataView(wavBuffer);

            // WAV header
            const writeString = (offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            };

            writeString(0, 'RIFF');
            view.setUint32(4, 36 + length * numberOfChannels * 2, true);
            writeString(8, 'WAVE');
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, numberOfChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * numberOfChannels * 2, true);
            view.setUint16(32, numberOfChannels * 2, true);
            view.setUint16(34, 16, true);
            writeString(36, 'data');
            view.setUint32(40, length * numberOfChannels * 2, true);

            // Write audio data
            let offset = 44;
            for (let i = 0; i < length; i++) {
                for (let channel = 0; channel < numberOfChannels; channel++) {
                    const sample = Math.max(-1, Math.min(1, audioBuffer.getChannelData(channel)[i]));
                    view.setInt16(offset, sample * 0x7FFF, true);
                    offset += 2;
                }
            }

            return new Blob([wavBuffer], { type: 'audio/wav' });
        }

        async function convertToMp3(audioBuffer, quality) {
            // Use lamejs for MP3 encoding
            const channels = audioBuffer.numberOfChannels;
            const sampleRate = audioBuffer.sampleRate;
            const kbps = quality === 'high' ? 320 : quality === 'medium' ? 192 : 128;

            const mp3encoder = new lamejs.Mp3Encoder(channels, sampleRate, kbps);
            const samples = audioBuffer.length;
            const sampleBlockSize = 1152;

            const mp3Data = [];

            const left = audioBuffer.getChannelData(0);
            const right = channels > 1 ? audioBuffer.getChannelData(1) : left;

            const leftInt = new Int16Array(left.length);
            const rightInt = new Int16Array(right.length);

            for (let i = 0; i < left.length; i++) {
                leftInt[i] = left[i] * 0x7FFF;
                rightInt[i] = right[i] * 0x7FFF;
            }

            for (let i = 0; i < samples; i += sampleBlockSize) {
                const leftChunk = leftInt.subarray(i, i + sampleBlockSize);
                const rightChunk = rightInt.subarray(i, i + sampleBlockSize);
                const mp3buf = mp3encoder.encodeBuffer(leftChunk, rightChunk);
                if (mp3buf.length > 0) {
                    mp3Data.push(mp3buf);
                }
            }

            const mp3buf = mp3encoder.flush();
            if (mp3buf.length > 0) {
                mp3Data.push(mp3buf);
            }

            return new Blob(mp3Data, { type: 'audio/mp3' });
        }

        async function convertToAiff(audioBuffer, quality) {
            const length = audioBuffer.length;
            const numberOfChannels = audioBuffer.numberOfChannels;
            const sampleRate = quality === 'high' ? audioBuffer.sampleRate :
                             quality === 'medium' ? 22050 : 11025;
            const bitsPerSample = 16;

            // Calculate sizes
            const dataSize = length * numberOfChannels * (bitsPerSample / 8);
            const totalSize = 54 + dataSize; // AIFF header is 54 bytes

            const aiffBuffer = new ArrayBuffer(totalSize);
            const view = new DataView(aiffBuffer);

            // Helper function to write string
            const writeString = (offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            };

            // Helper to write 32-bit big-endian integer
            const writeUint32BE = (offset, value) => {
                view.setUint32(offset, value, false);
            };

            // Helper to write 16-bit big-endian integer
            const writeUint16BE = (offset, value) => {
                view.setUint16(offset, value, false);
            };

            // Write AIFF header
            writeString(0, 'FORM');
            writeUint32BE(4, totalSize - 8);
            writeString(8, 'AIFF');

            // Write COMM chunk
            writeString(12, 'COMM');
            writeUint32BE(16, 18); // Chunk size
            writeUint16BE(20, numberOfChannels);
            writeUint32BE(22, length); // Number of sample frames
            writeUint16BE(26, bitsPerSample);

            // Write sample rate as 80-bit IEEE extended precision
            // Simplified: just write a basic representation
            const exponent = 0x400E; // Represents typical sample rate exponent
            writeUint16BE(28, exponent);
            writeUint32BE(30, sampleRate << 16);
            writeUint32BE(34, 0);

            // Write SSND chunk
            writeString(38, 'SSND');
            writeUint32BE(42, dataSize + 8); // Chunk size includes offset and block size
            writeUint32BE(46, 0); // Offset
            writeUint32BE(50, 0); // Block size

            // Write audio data (big-endian)
            let offset = 54;
            for (let i = 0; i < length; i++) {
                for (let channel = 0; channel < numberOfChannels; channel++) {
                    const sample = Math.max(-1, Math.min(1, audioBuffer.getChannelData(channel)[i]));
                    const int16 = Math.round(sample * 0x7FFF);
                    writeUint16BE(offset, int16);
                    offset += 2;
                }
            }

            return new Blob([aiffBuffer], { type: 'audio/aiff' });
        }

        async function convertToOggOrWebM(audioBuffer, format, quality) {
            // For OGG/WebM, we'll use MediaRecorder API if available
            const ctx = getAudioContext();
            const dest = ctx.createMediaStreamDestination();
            const source = ctx.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(dest);

            const chunks = [];
            const mimeType = format === 'webm' ? 'audio/webm;codecs=opus' : 'audio/ogg;codecs=opus';

            const bitrate = quality === 'high' ? 256000 : quality === 'medium' ? 128000 : 64000;

            const mediaRecorder = new MediaRecorder(dest.stream, {
                mimeType: mimeType,
                audioBitsPerSecond: bitrate
            });

            return new Promise((resolve) => {
                mediaRecorder.ondataavailable = e => chunks.push(e.data);
                mediaRecorder.onstop = () => {
                    const blob = new Blob(chunks, { type: mimeType });
                    resolve(blob);
                };

                mediaRecorder.start();
                source.start();

                setTimeout(() => {
                    mediaRecorder.stop();
                    source.stop();
                }, audioBuffer.duration * 1000);
            });
        }

        async function downloadFile(id) {
            const fileObj = audioFiles.find(f => f.id === id);

            let blob;
            let filename = fileObj.newName;

            if (fileObj.targetFormat) {
                // Change extension based on target format
                const nameWithoutExt = filename.substring(0, filename.lastIndexOf('.'));
                filename = `${nameWithoutExt}.${fileObj.targetFormat}`;

                // Convert if not already converted
                if (!fileObj.convertedBlob) {
                    blob = await convertAudio(fileObj, fileObj.targetFormat);
                    if (!blob) return; // Conversion failed
                } else {
                    blob = fileObj.convertedBlob;
                }
            } else {
                blob = fileObj.file;
            }

            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function removeFile(id) {
            const fileObj = audioFiles.find(f => f.id === id);
            URL.revokeObjectURL(fileObj.url);
            audioFiles = audioFiles.filter(f => f.id !== id);
            updateFilesList();
        }

        function clearAll() {
            audioFiles.forEach(fileObj => {
                URL.revokeObjectURL(fileObj.url);
            });
            audioFiles = [];
            updateFilesList();
        }

        async function downloadAll() {
            if (audioFiles.length === 0) return;

            for (let i = 0; i < audioFiles.length; i++) {
                await new Promise(resolve => setTimeout(resolve, 200));
                await downloadFile(audioFiles[i].id);
            }
        }

        async function batchConvert() {
            const format = document.getElementById('batchFormatSelect').value;
            if (!format) return;

            audioFiles.forEach(fileObj => {
                fileObj.targetFormat = format;
            });

            updateFilesList();

            alert(`All files will be converted to ${format.toUpperCase()} when downloaded`);
        }

        // Audio Splitter Functions
        async function openSplitter(fileId) {
            const fileObj = audioFiles.find(f => f.id === fileId);
            if (!fileObj) return;

            currentSplitterFile = fileObj;
            splitMarkers = [];

            // Load and decode audio
            const ctx = getAudioContext();
            const arrayBuffer = await fileObj.file.arrayBuffer();
            currentAudioBuffer = await ctx.decodeAudioData(arrayBuffer.slice(0));

            // Generate waveform
            await generateWaveform(currentAudioBuffer);

            // Update UI
            updateDuration();
            updateSegmentsList();

            // Show modal
            document.getElementById('splitterModal').classList.add('active');
        }

        function closeSplitter() {
            stopPlayback();
            currentSplitterFile = null;
            currentAudioBuffer = null;
            splitMarkers = [];
            document.getElementById('splitterModal').classList.remove('active');
        }

        async function generateWaveform(audioBuffer) {
            const canvas = document.getElementById('waveformCanvas');
            const ctx = canvas.getContext('2d');

            // Set canvas size
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            // Get audio data
            const channelData = audioBuffer.getChannelData(0);
            const samples = channelData.length;
            const samplesPerPixel = Math.floor(samples / canvas.width / zoomLevel);

            // Store waveform data for silence detection
            waveformData = [];

            // Clear canvas
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw waveform
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 1;
            ctx.beginPath();

            for (let x = 0; x < canvas.width; x++) {
                let min = 1.0;
                let max = -1.0;

                for (let i = 0; i < samplesPerPixel; i++) {
                    const index = x * samplesPerPixel + i;
                    if (index < samples) {
                        const sample = channelData[index];
                        if (sample < min) min = sample;
                        if (sample > max) max = sample;
                    }
                }

                waveformData.push({ min, max, avg: (min + max) / 2 });

                const yMin = ((min + 1) / 2) * canvas.height;
                const yMax = ((max + 1) / 2) * canvas.height;

                if (x === 0) {
                    ctx.moveTo(x, yMin);
                } else {
                    ctx.lineTo(x, yMin);
                }
                ctx.lineTo(x, yMax);
            }

            ctx.stroke();

            // Add click handler for manual splits
            canvas.onclick = (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const time = (x / canvas.width) * audioBuffer.duration;
                addSplitMarker(time);
            };
        }

        function detectSilence() {
            if (!waveformData || !currentAudioBuffer) return;

            const threshold = parseInt(document.getElementById('silenceThreshold').value) / 100;
            const minSilenceDuration = 0.5; // Minimum silence duration in seconds
            const canvas = document.getElementById('waveformCanvas');
            const samplesPerSecond = canvas.width / currentAudioBuffer.duration;
            const minSilenceSamples = minSilenceDuration * samplesPerSecond;

            splitMarkers = [];
            let silenceStart = null;
            let silenceCount = 0;

            for (let i = 0; i < waveformData.length; i++) {
                const amplitude = Math.abs(waveformData[i].max - waveformData[i].min);

                if (amplitude < threshold * 0.1) { // Silence detected
                    if (silenceStart === null) {
                        silenceStart = i;
                    }
                    silenceCount++;
                } else { // Sound detected
                    if (silenceCount > minSilenceSamples && silenceStart !== null) {
                        // Add split at the middle of silence period
                        const splitPoint = (silenceStart + i / 2) / canvas.width * currentAudioBuffer.duration;
                        addSplitMarker(splitPoint);
                    }
                    silenceStart = null;
                    silenceCount = 0;
                }
            }

            updateSegmentsList();
        }

        function addManualSplit() {
            // Add split at current playback position or middle if not playing
            const time = cursorPosition || currentAudioBuffer.duration / 2;
            addSplitMarker(time);
        }

        function addSplitMarker(time) {
            if (!splitMarkers.find(m => Math.abs(m - time) < 0.1)) {
                splitMarkers.push(time);
                splitMarkers.sort((a, b) => a - b);
                renderSplitMarkers();
                updateSegmentsList();
            }
        }

        function renderSplitMarkers() {
            const container = document.getElementById('splitMarkersContainer');
            const canvas = document.getElementById('waveformCanvas');

            container.innerHTML = splitMarkers.map((time, index) => {
                const x = (time / currentAudioBuffer.duration) * canvas.width;
                return `
                    <div class="split-marker" style="left: ${x + 20}px;"
                         onmousedown="startDragMarker(${index}, event)">
                        <div class="split-marker-label">${formatTime(time)}</div>
                    </div>
                `;
            }).join('');
        }

        function startDragMarker(index, e) {
            const canvas = document.getElementById('waveformCanvas');
            const container = document.getElementById('splitMarkersContainer');

            const onMouseMove = (e) => {
                const rect = container.getBoundingClientRect();
                const x = Math.max(0, Math.min(canvas.width, e.clientX - rect.left - 20));
                const time = (x / canvas.width) * currentAudioBuffer.duration;
                splitMarkers[index] = time;
                splitMarkers.sort((a, b) => a - b);
                renderSplitMarkers();
                updateSegmentsList();
            };

            const onMouseUp = () => {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            };

            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        }

        function clearAllSplits() {
            splitMarkers = [];
            renderSplitMarkers();
            updateSegmentsList();
        }

        function updateSegmentsList() {
            const container = document.getElementById('segmentsList');
            const segments = getSegments();

            container.innerHTML = segments.map((segment, index) => `
                <div class="segment-item">
                    <div class="segment-info">
                        <input type="text" class="segment-name-input"
                               id="segment-name-${index}"
                               value="${segment.name}"
                               placeholder="Segment ${index + 1}">
                        <span class="segment-time">
                            ${formatTime(segment.start)} - ${formatTime(segment.end)}
                            (${formatTime(segment.end - segment.start)})
                        </span>
                    </div>
                    <div class="segment-actions">
                        <button class="control-btn secondary" onclick="previewSegmentRange(${segment.start}, ${segment.end})">
                            Preview
                        </button>
                        <button class="control-btn primary" onclick="exportSegment(${index})">
                            Export
                        </button>
                    </div>
                </div>
            `).join('');
        }

        function getSegments() {
            const segments = [];
            let lastTime = 0;

            for (let i = 0; i <= splitMarkers.length; i++) {
                const endTime = i < splitMarkers.length ? splitMarkers[i] : currentAudioBuffer.duration;
                const baseName = currentSplitterFile.newName.replace(/\.[^/.]+$/, '');

                segments.push({
                    name: `${baseName}_part${i + 1}`,
                    start: lastTime,
                    end: endTime
                });

                lastTime = endTime;
            }

            return segments;
        }

        async function exportSegment(index) {
            const segments = getSegments();
            const segment = segments[index];
            const nameInput = document.getElementById(`segment-name-${index}`);
            const segmentName = nameInput.value || segment.name;
            const format = document.getElementById('segmentFormat').value;

            const segmentBuffer = extractSegment(currentAudioBuffer, segment.start, segment.end);

            let blob;
            switch(format) {
                case 'wav':
                    blob = await convertToWav(segmentBuffer, 'high');
                    break;
                case 'mp3':
                    blob = await convertToMp3(segmentBuffer, 'high');
                    break;
                case 'ogg':
                    blob = await convertToOggOrWebM(segmentBuffer, 'ogg', 'high');
                    break;
                case 'aif':
                    blob = await convertToAiff(segmentBuffer, 'high');
                    break;
            }

            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${segmentName}.${format}`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        async function exportAllSegments() {
            const segments = getSegments();
            const format = document.getElementById('segmentFormat').value;

            for (let i = 0; i < segments.length; i++) {
                await new Promise(resolve => setTimeout(resolve, 200));
                await exportSegment(i);
            }
        }

        function extractSegment(audioBuffer, startTime, endTime) {
            const ctx = getAudioContext();
            const startSample = Math.floor(startTime * audioBuffer.sampleRate);
            const endSample = Math.floor(endTime * audioBuffer.sampleRate);
            const segmentLength = endSample - startSample;

            const segmentBuffer = ctx.createBuffer(
                audioBuffer.numberOfChannels,
                segmentLength,
                audioBuffer.sampleRate
            );

            for (let channel = 0; channel < audioBuffer.numberOfChannels; channel++) {
                const originalData = audioBuffer.getChannelData(channel);
                const segmentData = segmentBuffer.getChannelData(channel);

                for (let i = 0; i < segmentLength; i++) {
                    segmentData[i] = originalData[startSample + i];
                }
            }

            return segmentBuffer;
        }

        function togglePlayback() {
            if (isPlaying) {
                stopPlayback();
            } else {
                startPlayback();
            }
        }

        function startPlayback() {
            if (!currentAudioBuffer) return;

            const ctx = getAudioContext();
            playbackSource = ctx.createBufferSource();
            playbackSource.buffer = currentAudioBuffer;
            playbackSource.connect(ctx.destination);
            playbackSource.start();

            isPlaying = true;
            document.getElementById('playPauseIcon').textContent = '⏸';

            playbackSource.onended = () => {
                stopPlayback();
            };
        }

        function stopPlayback() {
            if (playbackSource) {
                playbackSource.stop();
                playbackSource = null;
            }
            isPlaying = false;
            document.getElementById('playPauseIcon').textContent = '▶';
        }

        function previewSegmentRange(start, end) {
            stopPlayback();

            const ctx = getAudioContext();
            const segmentBuffer = extractSegment(currentAudioBuffer, start, end);

            playbackSource = ctx.createBufferSource();
            playbackSource.buffer = segmentBuffer;
            playbackSource.connect(ctx.destination);
            playbackSource.start();

            isPlaying = true;
            document.getElementById('playPauseIcon').textContent = '⏸';

            playbackSource.onended = () => {
                stopPlayback();
            };
        }

        function updateDuration() {
            if (!currentAudioBuffer) return;
            document.getElementById('durationLabel').textContent = formatTime(currentAudioBuffer.duration);
        }

        function updateThreshold(value) {
            document.getElementById('thresholdValue').textContent = value + '%';
        }

        function zoomIn() {
            zoomLevel = Math.min(zoomLevel * 1.5, 10);
            if (currentAudioBuffer) generateWaveform(currentAudioBuffer);
        }

        function zoomOut() {
            zoomLevel = Math.max(zoomLevel / 1.5, 1);
            if (currentAudioBuffer) generateWaveform(currentAudioBuffer);
        }

        function resetZoom() {
            zoomLevel = 1;
            if (currentAudioBuffer) generateWaveform(currentAudioBuffer);
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function previewSegment() {
            // Preview the segment at cursor position
            const segments = getSegments();
            const time = cursorPosition || 0;

            for (let segment of segments) {
                if (time >= segment.start && time <= segment.end) {
                    previewSegmentRange(segment.start, segment.end);
                    break;
                }
            }
        }
    </script>
</body>
</html>